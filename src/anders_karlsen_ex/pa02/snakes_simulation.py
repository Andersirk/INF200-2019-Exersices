# -*- coding: utf-8 -*-

__author__ = "Anders Karlsen", "KÃ¥re Johnsen"
__email__ = "anderska@nmbu.no", "kajohnse@nmbu.no"

import random
from collections import Counter


class Board:
    """
    Defining the board with its snakes, ladders and the goal.
    """
    def __init__(self, *args, **kwargs):
        self.extra = args, kwargs
        self.ladders = {1: 40, 8: 10, 36: 52, 43: 62, 49: 79, 65: 82, 68: 85}
        self.snakes = {25: 5, 33: 3, 42: 30, 56: 37, 64: 27, 74: 12, 87: 70}
        self.resilient_move = False
        self.lazy_move = False
        self.goal = 90

    def goal_reached(self, position):
        """
        Returns true if a player has reached or moved beyond the goal.
        """
        if position >= self.goal:
            return True
        return False

    def position_adjustment(self, position):
        """
        Returns the number of positions the player must move forward or
        backward in case of a ladder or a snake.
        """
        if position in self.snakes.keys():
            self.resilient_move = True
            return self.snakes[position] - position
        elif position in self.ladders.keys():
            self.lazy_move = True
            return self.ladders[position] - position
        else:
            return 0


class Player:
    """
    Information about the players position and the players number of throws.
    """
    def __init__(self, board):
        self.board = board
        self.position = 0
        self.number_of_throws = 0

    def move(self):
        """
        Moves the player according to a die cast and and, if necessary,
        moves the player up a ladder or down a snake.
        """
        self.position += random.randint(1, 6)
        self.position += self.board.position_adjustment(self.position)
        self.number_of_throws += 1


class ResilientPlayer(Player):
    """
    Is a subclass og "Player" with a slightly more "resilient" moving behavior.
    """
    def __init__(self, board, extra_steps=1):
        super().__init__(board)
        self.extra_steps = extra_steps
        self.position = 0

    def move(self):
        """
        When a resilient player slips down a snake, he will take x extra steps
         in the next move.
        """
        self.position += random.randint(1, 6)
        if self.board.resilient_move:
            self.position += self.extra_steps
        self.position += self.board.position_adjustment(self.position)
        self.number_of_throws += 1


class LazyPlayer(Player):
    """
    Is a subclass og "Player" with a slightly more "lazy" moving behavior.
    """
    def __init__(self, board, dropped_steps=1):
        super().__init__(board)
        self.dropped_steps = dropped_steps
        self.position = 0

    def move(self):
        """
        When a lazy player slips down a snake, he will drop x extra steps
         in the next move.
        """
        throw = random.randint(1, 6)
        if self.board.lazy_move:
            if throw - self.dropped_steps <= 0:
                return
            self.position += throw - self.dropped_steps
        self.position += self.board.position_adjustment(self.position)
        self.number_of_throws += 1


class Simulation:
    """
    Gives the random number generator a seed, creates the player classes in a
     list of players, and if stated; randomizing the players list.
    """
    def __init__(
            self, player_field, randomize_players=True, seed=None, **kwargs
    ):
        self.extra = kwargs
        self.seed = seed
        if randomize_players:
            random.shuffle(player_field)
        self.list_of_players = player_field
        self.simulation_list = []

    def single_game(self):
        """
        Runs a single game and returning a tuple consisting of the number
         of moves made and the type of the winner.
        """
        list_of_initiated_players = [
            player(Board()) for player in self.list_of_players
        ]
        while True:
            for player in list_of_initiated_players:
                player.move()
                if player.board.goal_reached(player.position):
                    return player.number_of_throws, type(player).__name__

    def run_simulation(self, number_of_games):
        """
        Runs a given number of games and stores the results in the Simulation
         object. Returns nothing.
        """
        for _ in range(number_of_games):
            self.simulation_list.append(self.single_game())

    def get_results(self):
        """
        Returns all results generated by run_simulation() calls so far
         as a list of result tuples.
        """
        return self.simulation_list

    def winners_per_type(self):
        """
        Returns a dictionary mapping player types to the number of wins.
        """
        winners_dict = dict(
            Counter(element[1] for element in self.simulation_list)
        )
        unique_players = set([elem.__name__ for elem in self.list_of_players])
        for element in unique_players:
            if element not in winners_dict.keys():
                winners_dict[element] = 0
        return winners_dict

    def durations_per_type(self):
        """
        Returns a dictionary mapping player types to lists of game durations
         for that type.
        """
        duration_dict = {}
        for element in self.simulation_list:
            str_elem = str(element[1])
            if str_elem in duration_dict.keys():
                duration_dict[str_elem].append(element[0])
            else:
                duration_dict[str_elem] = [element[0]]
        return duration_dict

    def players_per_type(self):
        """
        Returns a dictionary showing how many players of each type participate.
        """
        return dict(Counter(elem.__name__ for elem in self.list_of_players))


if __name__ == "__main__":
    testert = Simulation(
        [Player, ResilientPlayer, LazyPlayer, ResilientPlayer], seed=69
    )
    testert.run_simulation(10)
    print(testert.get_results())
    print(testert.winners_per_type())
    print(testert.durations_per_type())
    print(testert.players_per_type())
